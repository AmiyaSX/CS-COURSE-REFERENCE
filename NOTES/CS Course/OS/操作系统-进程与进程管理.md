# 进程 Process
> 可并发执行的程序在一个数据集合上的一次运行过程，是系统进行资源分配和调度的一个独立单位。

- 动态性：
	- 具有生命周期
	- 具有不同的状态
- 结构特征 = `程序 + 数据 + PCB（Process Control Block）`
	- PCB：进程控制块，进程的动态特征，该进程与其他进程和系统资源的关系（PCB是有限的，用完要回收）
- 独立性：
	- 系统进行资源分配和调度的独立单位，是能运行的基本单位
- 并发性
- 异步性

### 进程的状态及变迁
![](https://pic3.zhimg.com/80/v2-7030fc6c55969e8b22c0792bcd00ea62_1440w.webp)
- 就绪状态：分配到必要资源，形成就绪队列，一旦获得CPU控制权就立刻运行
- 运行状态：得到CPU资源
- 阻塞状态(等待状态)：由于发生某事件而暂时无法继续执行，组织成一个或多个阻塞队列

由运行态到阻塞态是主动的，阻塞态到就绪态是被动的

#### Linux：fork()
1. 为新进程分配一个新的PCB结构
2. 给子进程一个唯一的进程标识号
3. 给子进程一个父进程上下文的逻辑副本（执行完全相同的代码）
4. 增加与该进程相关联的文件表和索引节点表的引用数
5. 对父进程返回子进程的进程号，对子进程返回0

>一个父进程可以创建另一个子进程，子进程可以继承父进程的所有资源
>
>子进程被撤销时，父进程会回收所有资源，当父进程被撤销，其所有子进程一同被撤销

### 进程之间的制约关系

1. 资源
	-  临界资源：一次只允许一个进程使用的资源
		- 硬件：I / O、磁带机
		- 软件：公用变量、数据、表格、队列
		- 临界区：进程中访问临界资源的一段代码

2. 进程可以互斥的访问临界区

## 进程同步与互斥机制

### 进程同步机制
>并发进程在一些关键点上可能需要**互相等待**或**互通消息**，这种相互制约的等待或互通消息称为进程同步。（进程 A 应在进程 B 之前执行）

原则：
- 空闲让进
- 忙则等待
- 有限等待
- 让权等待

### 进程互斥
> 资源在同一时刻只能允许一个进程使用，逐次使用临界资源。（进程 A 和进程 B 不能在同一时刻执行）

#### 锁机制实现互斥

锁的定义：锁 代表某种资源的状态（可用变量w表示）

`上锁操作`：临界资源的申请
- 监测w的值（0/1）
- w为1，持续监测
- w为0，锁位置1表示资源占用，进入临界区执行

`开锁操作`：临界资源的释放
- 临界资源使用完毕，将锁位置0

> 加锁操作 -> 执行临界区程序 -> 开锁操作


#### 信号灯机制（信号量与 PV 操作）
	一个确定的二元组（s,q）

- 「P操作」：信号量减1，申请一个资源
- 「V操作」：信号量加1，释放一个资源

1. 实现进程互斥：**「P 操作和 V 操作必须成对出现」**
```
互斥信号量初始化为1
将临界资源访问量放置在P和V操作之间
mutex = 1
P1() {
	...
	P(s)
	临界区
	V(s)
}
P2() {
	...
	P(s)
	临界区
	V(s)
}
```
2. 实现进程同步
```
同步信号量初始化为0
s = 0

P1() {
	act 1
	act 2
	V(s)  //相当于一个唤醒操作
	act3
}
P2() {
	P(s)
	act 4
	act 5
	act 6
}
```
##### 生产者和消费者问题
- 两个同步关系(对应两个同步信号量)：缓冲区的空和满对消费者和生产者的约束关系
- 互斥关系(对应一个互斥信号量)：两者必须互斥地访问缓冲区

##### 读者-写者问题
>允许多个读者同时读一个共享对象，但禁止读者、写者同时访问一个共享对象，也禁止多个写者访问一个共享对象

##### 哲学家进餐问题

>死锁情况：每个哲学家手中只拿了一只筷子
>策略：让哲学家同时拿起两只筷子

### 进程的调度算法
- **先到先服务**
- **短作业优先**
- **时间片轮转调度**
- **多级反馈队列调度**（兼顾高优先级和短进程优先）
- **优先级调度**

## 进程通信

# 线程
>操作系统能够进行运算**调度的最小单位**。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务。

`线程是独立调度和分派的基本单位。(一个基本的CPU执行单元)`

**同一进程中的多条线程将共享该进程中的全部系统资源**，如虚拟地址空间，文件描述符和信号处理等等。但是同一进程中的多个线程有各自的调用栈，自己的寄存环境，自己的线程本地存储。

## 区别于进程
- 引入线程后，*进程*只作为除CPU外的**系统资源的分配单元**，而*线程*作为**CPU的分配单元**
- 同一个进程之间的线程是可以共享资源，线程通信可以**直接读写**同属一个进程的程序段来通信

## 实现方式

### 用户级线程
>线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。

线程的切换可以直接在用户态完成
系统的开销小，效率高

当一个线程被阻塞后别的线程都不能再使用处理机

### 内核级线程
>线程管理的所有工作都由内核完成，应用程序没有进行线程管理的代码

当一个线程被阻塞后，别的还可以继续执行
并发能力强，多核CPU可以运行多个线程

当线程切换的话CPU需要从用户态切换到内核态，成本开销大。

# 协程
>用户态的轻量级线程，协程的调度完全由用户控制

- **高效率**：没有线程切换的开销
- **不需要锁机制**：线程和进程是同步的，协程是异步的

```c++
main() {
	int s1 = 1
	int s2, s3, s4, s5 = 0;
	p1();
	p2();
	p3();
	p4();
	p5(); 
}
p1() {
	p(s1);
	...
	v(s2);
	v(s3);
	v(s4);
	v(s1);
}
p2() {
	p(s2);
	...
}
p3() {
	p(s3);
	...
	v(s3);
	
}
p4() {
	p(s4);
	...
	v(s4);
}
p5() {
	p(s1);
	p(s3);
	p(s4);
	...
}
```

## 死锁

### 主要原因
- 系统资源不够
- 进程运行推进顺序不当
- 资源分配不当

### 死锁产生的四个条件
- 互斥条件：资源一次只能被一个进程使用
- 请求与保持条件：一个进程因为请求资源而阻塞时，对已经获得的资源保持不放
- 不可剥夺条件：一个进程获得的资源在使用完之前，不能进行资源的剥夺
- 循环等待条件：进程之间存在头尾相接的循环等待关系

### 死锁的接触与预防

资源的合理分配算法, 避免进程永久占用资源

#### 预先资源分配法
>一次性申请所有资源，只要有一种资源不满足需求就不予分配

#### 有序资源分配法
>破环原本的环路等待条件，在申请不同类资源时必须按指定顺序去申请

#### 银行家算法
>分配资源前先判断系统的安全性再决定是否予以分配

#### 解除死锁方法
>结合具体业务场景，撤销/挂起线程/进程，使资源释放。

